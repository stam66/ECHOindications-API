<?lc
-- Indications CRUD API - Using LiveCode Arrays
-- Public: list, read, list_by_context
-- Protected: create, update, delete

include "lib/db-functions.lc"

on startup
  -- Set security headers first
  setSecurityHeaders
  put header "Content-Type: application/json"

  put $_GET["action"] into tAction
  put $_GET["id"] into tID
  put $_GET["context_id"] into tContextID
  put $_GET["username"] into tUsername
  put $_POST_RAW into tPostData
  
  put dbConnect() into tConnectionID
  if tConnectionID begins with "ERROR:" then
    put jsonError(tConnectionID)
    exit startup
  end if
  
  switch tAction
    case "list"
      -- PUBLIC: No auth required
      put handleListIndications(tConnectionID) into tResponse
      break
    case "list_by_context"
      -- PUBLIC: No auth required
      put handleListByContext(tConnectionID, tContextID) into tResponse
      break
    case "read"
      -- PUBLIC: No auth required
      put handleReadIndication(tConnectionID, tID) into tResponse
      break
    case "create"
      -- PROTECTED: Auth required
      put requireAuth() into tAuthUser
      put handleCreateIndication(tConnectionID, tPostData, tUsername) into tResponse
      break
    case "update"
      -- PROTECTED: Auth required
      put requireAuth() into tAuthUser
      put handleUpdateIndication(tConnectionID, tPostData, tUsername) into tResponse
      break
    case "delete"
      -- PROTECTED: Auth required
      put requireAuth() into tAuthUser
      put handleDeleteIndication(tConnectionID, tID, tUsername) into tResponse
      break
    default
      put jsonError("Invalid action. Use: list, list_by_context, read, create, update, delete") into tResponse
  end switch
  
  revCloseDatabase tConnectionID
  put tResponse
end startup

startup

function handleListIndications pConnectionID
  put "SELECT i.id, i.title, i.keywords, i.comments, i.primary_care, i.secondary_inpatient," into tSQL
  put " i.secondary_outpatient, i.source_ase, i.source_eacvi, i.source_bse, i.source_consensus," after tSQL
  put " i.urgency, i.created_at, i.updated_at," after tSQL
  put " GROUP_CONCAT(c.id ORDER BY c.sort_order SEPARATOR ',') as context_ids," after tSQL
  put " GROUP_CONCAT(c.name ORDER BY c.sort_order SEPARATOR '||') as context_names" after tSQL
  put " FROM indications i" after tSQL
  put " LEFT JOIN indication_contexts ic ON i.id = ic.indication_id" after tSQL
  put " LEFT JOIN contexts c ON ic.context_id = c.id AND c.is_active = 1" after tSQL
  put " GROUP BY i.id" after tSQL
  put " ORDER BY i.title" after tSQL
  
  put revDataFromQuery(tab, return, pConnectionID, tSQL) into tData
  
  if tData begins with "revdberr" then
    return jsonError(tData)
  end if
  
  -- Build array of indications
  put 1 into tIndex
  repeat for each line tLine in tData
    split tLine by tab
    
    -- Basic fields
    put tLine[1] into tIndications[tIndex]["id"]
    put tLine[2] into tIndications[tIndex]["title"]
    put tLine[3] into tIndications[tIndex]["keywords"]
    put tLine[4] into tIndications[tIndex]["comments"]
    put tLine[5] into tIndications[tIndex]["primary_care"]
    put tLine[6] into tIndications[tIndex]["secondary_inpatient"]
    put tLine[7] into tIndications[tIndex]["secondary_outpatient"]
    
    -- Source fields
    put tLine[8] into tIndications[tIndex]["source_ase"]
    put tLine[9] into tIndications[tIndex]["source_eacvi"]
    put tLine[10] into tIndications[tIndex]["source_bse"]
    put tLine[11] into tIndications[tIndex]["source_consensus"]
    
    put tLine[12] into tIndications[tIndex]["urgency"]
    put tLine[13] into tIndications[tIndex]["created_at"]
    put tLine[14] into tIndications[tIndex]["updated_at"]
    
    -- Parse contexts into array
    put tLine[15] into tContextIDs
    put tLine[16] into tContextNames
    
    if tContextIDs is not empty then
      split tContextIDs by ","
      split tContextNames by "||"
      
      put 1 into tCtxIndex
      repeat for each element tCtxID in tContextIDs
        put tCtxID into tIndications[tIndex]["contexts"][tCtxIndex]["id"]
        put tContextNames[tCtxIndex] into tIndications[tIndex]["contexts"][tCtxIndex]["name"]
        add 1 to tCtxIndex
      end repeat
    else
      put empty into tIndications[tIndex]["contexts"]
    end if
    
    add 1 to tIndex
  end repeat
  
  return jsonSuccess(tIndications)
end handleListIndications

function handleListByContext pConnectionID, pContextID
  if pContextID is empty then
    return jsonError("Context ID required")
  end if
  
  if validateNumericID(pContextID) is empty then
    return jsonError("Invalid context ID")
  end if
  
  put pContextID into tSafeID
  
  put "SELECT i.id, i.title, i.keywords, i.primary_care, i.urgency," into tSQL
  put " GROUP_CONCAT(c.name ORDER BY c.sort_order SEPARATOR ', ') as context_names" after tSQL
  put " FROM indications i" after tSQL
  put " INNER JOIN indication_contexts ic ON i.id = ic.indication_id" after tSQL
  put " LEFT JOIN contexts c ON ic.context_id = c.id" after tSQL
  put " WHERE i.id IN (SELECT indication_id FROM indication_contexts WHERE context_id =" && tSafeID & ")" after tSQL
  put " GROUP BY i.id" after tSQL
  put " ORDER BY i.title" after tSQL
  
  put revDataFromQuery(tab, return, pConnectionID, tSQL) into tData
  
  if tData begins with "revdberr" then
    return jsonError(tData)
  end if
  
  put 1 into tIndex
  repeat for each line tLine in tData
    split tLine by tab
    
    put tLine[1] into tIndications[tIndex]["id"]
    put tLine[2] into tIndications[tIndex]["title"]
    put tLine[3] into tIndications[tIndex]["keywords"]
    put tLine[4] into tIndications[tIndex]["primary_care"]
    put tLine[5] into tIndications[tIndex]["urgency"]
    put tLine[6] into tIndications[tIndex]["contexts"]
    
    add 1 to tIndex
  end repeat
  
  return jsonSuccess(tIndications)
end handleListByContext

function handleReadIndication pConnectionID, pID
  if pID is empty then
    return jsonError("Indication ID required")
  end if
  
  if validateNumericID(pID) is empty then
    return jsonError("Invalid indication ID")
  end if
  
  put pID into tSafeID
  
  put "SELECT i.*, GROUP_CONCAT(c.id ORDER BY c.sort_order SEPARATOR ',') as context_ids," into tSQL
  put " GROUP_CONCAT(c.name ORDER BY c.sort_order SEPARATOR '||') as context_names" after tSQL
  put " FROM indications i" after tSQL
  put " LEFT JOIN indication_contexts ic ON i.id = ic.indication_id" after tSQL
  put " LEFT JOIN contexts c ON ic.context_id = c.id" after tSQL
  put " WHERE i.id =" && tSafeID after tSQL
  put " GROUP BY i.id" after tSQL
  
  put revDataFromQuery(tab, return, pConnectionID, tSQL) into tData
  
  if tData begins with "revdberr" or tData is empty then
    return jsonError("Indication not found")
  end if
  
  split tData by tab
  
  put tData[1] into tIndication["id"]
  put tData[2] into tIndication["title"]
  put tData[3] into tIndication["keywords"]
  put tData[4] into tIndication["comments"]
  put tData[5] into tIndication["primary_care"]
  put tData[6] into tIndication["secondary_inpatient"]
  put tData[7] into tIndication["secondary_outpatient"]
  put tData[8] into tIndication["source_ase"]
  put tData[9] into tIndication["source_eacvi"]
  put tData[10] into tIndication["source_bse"]
  put tData[11] into tIndication["source_consensus"]
  put tData[12] into tIndication["created_at"]
  put tData[13] into tIndication["updated_at"]
  put tData[14] into tIndication["urgency"]
  
  put tData[15] into tContextIDs
  put tData[16] into tContextNames
  
  if tContextIDs is not empty then
    split tContextIDs by ","
    split tContextNames by "||"
    
    put 1 into tCtxIndex
    repeat for each element tCtxID in tContextIDs
      put tCtxID into tIndication["contexts"][tCtxIndex]["id"]
      put tContextNames[tCtxIndex] into tIndication["contexts"][tCtxIndex]["name"]
      add 1 to tCtxIndex
    end repeat
  else
    put empty into tIndication["contexts"]
  end if
  
  return jsonSuccess(tIndication)
end handleReadIndication

function handleCreateIndication pConnectionID, pPostData, pUsername
  if pPostData is empty then
    return jsonError("No data provided")
  end if

  -- Parse JSON
  put JSONParser(pPostData) into tData

  if tData is not an array then
    return jsonError("Invalid JSON format")
  end if

  -- Extract and validate required fields
  put tData["title"] into tTitle
  if tTitle is empty then
    return jsonError("Title is required")
  end if

  -- Extract optional fields with defaults
  put tData["keywords"] into tKeywords
  put tData["comments"] into tComments
  put tData["primary_care"] into tPrimaryCare
  put tData["secondary_inpatient"] into tSecondaryInpatient
  put tData["secondary_outpatient"] into tSecondaryOutpatient
  put tData["source_ase"] into tSourceASE
  put tData["source_eacvi"] into tSourceEACVI
  put tData["source_bse"] into tSourceBSE
  put tData["source_consensus"] into tSourceConsensus
  put tData["urgency"] into tUrgency
  put tData["contexts"] into tContexts

  -- Escape string values for SQL
  put sqlEscape(tTitle) into tSafeTitle
  put sqlEscape(tKeywords) into tSafeKeywords
  put sqlEscape(tComments) into tSafeComments
  put sqlEscape(tUrgency) into tSafeUrgency

  -- Convert care setting fields to ENUM values ('indicated', 'not_indicated', 'can_be_considered')
  -- Accept: true/1/"1"/"indicated" -> "indicated", false/0/"0"/"not_indicated" -> "not_indicated"
  -- Also accept "can_be_considered" directly
  if tPrimaryCare = "can_be_considered" then
    put "can_be_considered" into tPrimaryCare
  else if tPrimaryCare is true or tPrimaryCare = 1 or tPrimaryCare = "1" or tPrimaryCare = "indicated" then
    put "indicated" into tPrimaryCare
  else
    put "not_indicated" into tPrimaryCare
  end if
  if tSecondaryInpatient = "can_be_considered" then
    put "can_be_considered" into tSecondaryInpatient
  else if tSecondaryInpatient is true or tSecondaryInpatient = 1 or tSecondaryInpatient = "1" or tSecondaryInpatient = "indicated" then
    put "indicated" into tSecondaryInpatient
  else
    put "not_indicated" into tSecondaryInpatient
  end if
  if tSecondaryOutpatient = "can_be_considered" then
    put "can_be_considered" into tSecondaryOutpatient
  else if tSecondaryOutpatient is true or tSecondaryOutpatient = 1 or tSecondaryOutpatient = "1" or tSecondaryOutpatient = "indicated" then
    put "indicated" into tSecondaryOutpatient
  else
    put "not_indicated" into tSecondaryOutpatient
  end if

  -- Convert source fields to integers (these ARE tinyint columns)
  if tSourceASE is true or tSourceASE = 1 or tSourceASE = "1" then
    put 1 into tSourceASE
  else
    put 0 into tSourceASE
  end if
  if tSourceEACVI is true or tSourceEACVI = 1 or tSourceEACVI = "1" then
    put 1 into tSourceEACVI
  else
    put 0 into tSourceEACVI
  end if
  if tSourceBSE is true or tSourceBSE = 1 or tSourceBSE = "1" then
    put 1 into tSourceBSE
  else
    put 0 into tSourceBSE
  end if
  if tSourceConsensus is true or tSourceConsensus = 1 or tSourceConsensus = "1" then
    put 1 into tSourceConsensus
  else
    put 0 into tSourceConsensus
  end if

  -- Validate urgency ENUM value
  if tUrgency is not among the items of "urgent,soon,routine,can_be_considered,not_indicated" then
    put "not_indicated" into tUrgency
  end if
  put sqlEscape(tUrgency) into tSafeUrgency

  -- Build INSERT query
  put "INSERT INTO indications (title, keywords, comments, primary_care, secondary_inpatient," into tSQL
  put " secondary_outpatient, source_ase, source_eacvi, source_bse, source_consensus, urgency," after tSQL
  put " created_at, updated_at) VALUES ('" after tSQL
  put tSafeTitle & "', '" & tSafeKeywords & "', '" & tSafeComments & "', '" after tSQL
  put tPrimaryCare & "', '" & tSecondaryInpatient & "', '" & tSecondaryOutpatient & "', " after tSQL
  put tSourceASE & ", " & tSourceEACVI & ", " & tSourceBSE & ", " & tSourceConsensus & ", '" after tSQL
  put tSafeUrgency & "', NOW(), NOW())" after tSQL

  revExecuteSQL pConnectionID, tSQL

  if the result is not empty then
    return jsonError("Failed to create indication: " & the result)
  end if

  -- Get the newly created ID
  put revDataFromQuery(tab, return, pConnectionID, "SELECT LAST_INSERT_ID()") into tNewID
  put line 1 of tNewID into tNewID

  -- Insert context associations if provided
  if tContexts is an array then
    repeat for each element tContext in tContexts
      -- Handle both {id: X} objects and plain ID numbers
      if tContext is an array then
        put tContext["id"] into tContextID
      else
        put tContext into tContextID
      end if

      if validateNumericID(tContextID) is not empty then
        put "INSERT INTO indication_contexts (indication_id, context_id) VALUES (" & tNewID & ", " & tContextID & ")" into tCtxSQL
        revExecuteSQL pConnectionID, tCtxSQL
      end if
    end repeat
  end if

  -- Log to audit table
  if pUsername is empty then
    put "system" into pUsername
  end if
  put sqlEscape(pUsername) into tSafeUser
  put "INSERT INTO audit (audit_user, audit_table, audit_primarykey, action, old_values)" into tAuditSQL
  put " VALUES ('" & tSafeUser & "', 'indications', " & tNewID & ", 'create', NULL)" after tAuditSQL
  revExecuteSQL pConnectionID, tAuditSQL

  -- Return the newly created indication
  return handleReadIndication(pConnectionID, tNewID)
end handleCreateIndication

function handleUpdateIndication pConnectionID, pPostData, pUsername
  if pPostData is empty then
    return jsonError("No data provided")
  end if

  -- Parse JSON
  put JSONParser(pPostData) into tData

  if tData is not an array then
    return jsonError("Invalid JSON format")
  end if

  -- Extract and validate ID
  put tData["id"] into tID
  if tID is empty then
    return jsonError("Indication ID is required")
  end if

  if validateNumericID(tID) is empty then
    return jsonError("Invalid indication ID")
  end if

  put tID into tSafeID

  -- Get old data for audit log before updating
  put handleReadIndication(pConnectionID, tSafeID) into tOldDataJSON

  -- Check if indication exists
  put JSONParser(tOldDataJSON) into tOldData
  if tOldData["status"] is "error" then
    return jsonError("Indication not found")
  end if

  -- Extract fields from request
  put tData["title"] into tTitle
  put tData["keywords"] into tKeywords
  put tData["comments"] into tComments
  put tData["primary_care"] into tPrimaryCare
  put tData["secondary_inpatient"] into tSecondaryInpatient
  put tData["secondary_outpatient"] into tSecondaryOutpatient
  put tData["source_ase"] into tSourceASE
  put tData["source_eacvi"] into tSourceEACVI
  put tData["source_bse"] into tSourceBSE
  put tData["source_consensus"] into tSourceConsensus
  put tData["urgency"] into tUrgency
  put tData["contexts"] into tContexts

  -- Validate required fields
  if tTitle is empty then
    return jsonError("Title is required")
  end if

  -- Escape string values for SQL
  put sqlEscape(tTitle) into tSafeTitle
  put sqlEscape(tKeywords) into tSafeKeywords
  put sqlEscape(tComments) into tSafeComments

  -- Convert care setting fields to ENUM values ('indicated', 'not_indicated', 'can_be_considered')
  if tPrimaryCare = "can_be_considered" then
    put "can_be_considered" into tPrimaryCare
  else if tPrimaryCare is true or tPrimaryCare = 1 or tPrimaryCare = "1" or tPrimaryCare = "indicated" then
    put "indicated" into tPrimaryCare
  else
    put "not_indicated" into tPrimaryCare
  end if
  if tSecondaryInpatient = "can_be_considered" then
    put "can_be_considered" into tSecondaryInpatient
  else if tSecondaryInpatient is true or tSecondaryInpatient = 1 or tSecondaryInpatient = "1" or tSecondaryInpatient = "indicated" then
    put "indicated" into tSecondaryInpatient
  else
    put "not_indicated" into tSecondaryInpatient
  end if
  if tSecondaryOutpatient = "can_be_considered" then
    put "can_be_considered" into tSecondaryOutpatient
  else if tSecondaryOutpatient is true or tSecondaryOutpatient = 1 or tSecondaryOutpatient = "1" or tSecondaryOutpatient = "indicated" then
    put "indicated" into tSecondaryOutpatient
  else
    put "not_indicated" into tSecondaryOutpatient
  end if

  -- Convert source fields to integers (these ARE tinyint columns)
  if tSourceASE is true or tSourceASE = 1 or tSourceASE = "1" then
    put 1 into tSourceASE
  else
    put 0 into tSourceASE
  end if
  if tSourceEACVI is true or tSourceEACVI = 1 or tSourceEACVI = "1" then
    put 1 into tSourceEACVI
  else
    put 0 into tSourceEACVI
  end if
  if tSourceBSE is true or tSourceBSE = 1 or tSourceBSE = "1" then
    put 1 into tSourceBSE
  else
    put 0 into tSourceBSE
  end if
  if tSourceConsensus is true or tSourceConsensus = 1 or tSourceConsensus = "1" then
    put 1 into tSourceConsensus
  else
    put 0 into tSourceConsensus
  end if

  -- Validate urgency ENUM value
  if tUrgency is not among the items of "urgent,soon,routine,can_be_considered,not_indicated" then
    put "not_indicated" into tUrgency
  end if
  put sqlEscape(tUrgency) into tSafeUrgency

  -- Build UPDATE query
  put "UPDATE indications SET" into tSQL
  put " title = '" & tSafeTitle & "'," after tSQL
  put " keywords = '" & tSafeKeywords & "'," after tSQL
  put " comments = '" & tSafeComments & "'," after tSQL
  put " primary_care = '" & tPrimaryCare & "'," after tSQL
  put " secondary_inpatient = '" & tSecondaryInpatient & "'," after tSQL
  put " secondary_outpatient = '" & tSecondaryOutpatient & "'," after tSQL
  put " source_ase = " & tSourceASE & "," after tSQL
  put " source_eacvi = " & tSourceEACVI & "," after tSQL
  put " source_bse = " & tSourceBSE & "," after tSQL
  put " source_consensus = " & tSourceConsensus & "," after tSQL
  put " urgency = '" & tSafeUrgency & "'," after tSQL
  put " updated_at = NOW()" after tSQL
  put " WHERE id = " & tSafeID after tSQL

  revExecuteSQL pConnectionID, tSQL

  if the result is not empty then
    return jsonError("Failed to update indication: " & the result)
  end if

  -- Delete existing context associations
  put "DELETE FROM indication_contexts WHERE indication_id = " & tSafeID into tDelCtxSQL
  revExecuteSQL pConnectionID, tDelCtxSQL

  -- Insert new context associations if provided
  if tContexts is an array then
    repeat for each element tContext in tContexts
      -- Handle both {id: X} objects and plain ID numbers
      if tContext is an array then
        put tContext["id"] into tContextID
      else
        put tContext into tContextID
      end if

      if validateNumericID(tContextID) is not empty then
        put "INSERT INTO indication_contexts (indication_id, context_id) VALUES (" & tSafeID & ", " & tContextID & ")" into tCtxSQL
        revExecuteSQL pConnectionID, tCtxSQL
      end if
    end repeat
  end if

  -- Log to audit table
  if pUsername is empty then
    put "system" into pUsername
  end if
  put sqlEscape(pUsername) into tSafeUser
  put sqlEscape(tOldDataJSON) into tSafeOldJSON
  put "INSERT INTO audit (audit_user, audit_table, audit_primarykey, action, old_values)" into tAuditSQL
  put " VALUES ('" & tSafeUser & "', 'indications', " & tSafeID & ", 'update', '" & tSafeOldJSON & "')" after tAuditSQL
  revExecuteSQL pConnectionID, tAuditSQL

  -- Return the updated indication
  return handleReadIndication(pConnectionID, tSafeID)
end handleUpdateIndication

function handleDeleteIndication pConnectionID, pID, pUsername
  if pID is empty then
    return jsonError("Indication ID required")
  end if
  
  if validateNumericID(pID) is empty then
    return jsonError("Invalid indication ID")
  end if
  
  put pID into tSafeID
  
  if pUsername is empty then
    put "system" into pUsername
  end if
  
  put handleReadIndication(pConnectionID, tSafeID) into tOldDataJSON
  
  put "DELETE FROM indication_contexts WHERE indication_id =" && tSafeID into tSQL
  revExecuteSQL pConnectionID, tSQL
  
  put "DELETE FROM indications WHERE id =" && tSafeID into tSQL2
  revExecuteSQL pConnectionID, tSQL2
  
  if the result is not empty then
    return jsonError(the result)
  end if
  
  put sqlEscape(pUsername) into tSafeUser
  put sqlEscape(tOldDataJSON) into tSafeJSON
  put "INSERT INTO audit (audit_user, audit_table, audit_primarykey, action, old_values)" into tAuditSQL
  put " VALUES ('" & tSafeUser & "', 'indications'," && tSafeID & ", 'delete', '" & tSafeJSON & "')" after tAuditSQL
  revExecuteSQL pConnectionID, tAuditSQL
  
  put "Indication deleted successfully" into tResult
  return jsonSuccess(tResult)
end handleDeleteIndication
?>
