<?lc
-- Authentication API

include "lib/db-functions.lc"

on startup
  -- Set security headers first
  setSecurityHeaders
  put header "Content-Type: application/json"

  put $_GET["action"] into tAction
  put $_POST_RAW into tPostData

  switch tAction
    case "login"
      put handleLogin(tPostData) into tResponse
      break
    case "refresh"
      put handleRefresh() into tResponse
      break
    case "requestReset"
      put handleRequestReset(tPostData) into tResponse
      break
    case "changePassword"
      put handleChangePassword(tPostData) into tResponse
      break
    default
      put jsonError("Invalid action. Use: login, refresh, requestReset, changePassword") into tResponse
  end switch

  put tResponse
end startup

startup

function handleLogin pPostData
  if pPostData is empty then
    return jsonError("No data provided")
  end if

  -- Parse JSON
  put JSONParser(pPostData) into tData

  if tData is not an array then
    return jsonError("Invalid JSON format")
  end if

  put tData["username"] into tUsername
  put tData["password"] into tPassword

  if tUsername is empty or tPassword is empty then
    return jsonError("Username and password required")
  end if

  -- Connect to database
  put dbConnect() into tConnectionID
  if tConnectionID begins with "ERROR:" then
    return jsonError(tConnectionID)
  end if

  -- Check rate limiting: 7 failed attempts per 15 minutes (900 seconds)
  -- IMPORTANT: Uses distinct endpoint key "login" - separate from "requestReset" counter
  put getClientIP() into tClientIP
  put checkRateLimit(tConnectionID, tClientIP, "login", 7, 900) into tRateLimitError

  if tRateLimitError is not empty then
    revCloseDatabase tConnectionID
    put header "Status: 429 Too Many Requests"
    return jsonError(tRateLimitError)
  end if

  -- Get user from database (including OTP flag for password reset flow)
  put "SELECT id, username, password_hash, email, name, password_salt, is_active, OTP FROM users WHERE username = '" & sqlEscape(tUsername) & "'" into tSQL
  put revDataFromQuery(tab, return, tConnectionID, tSQL) into tUserData

  if tUserData begins with "revdberr" or tUserData is empty then
    recordFailedAttempt tConnectionID, tClientIP, "login"
    revCloseDatabase tConnectionID
    return jsonError("Invalid username or password")
  end if

  split tUserData by tab

  -- Check if user is active
  if tUserData[7] is not 1 then
    recordFailedAttempt tConnectionID, tClientIP, "login"
    revCloseDatabase tConnectionID
    return jsonError("User account is inactive")
  end if

  -- Verify password
  put tUserData[3] into tStoredHash      -- Column 3 is password_hash
  put tUserData[6] into tSalt            -- Column 6 is password_salt

  -- Determine the full hash format:
  -- If password_hash already contains ":", it includes the salt, use as-is
  -- Otherwise, construct "salt:hash" if salt exists
  if ":" is in tStoredHash then
    -- Hash already in "salt:hash" format
    put tStoredHash into tFullHash
  else if tSalt is not empty then
    -- Separate salt column - construct "salt:hash"
    put tSalt & ":" & tStoredHash into tFullHash
  else
    -- Old format - plain hash with no salt
    put tStoredHash into tFullHash
  end if

  if not verifyPassword(tPassword, tFullHash) then
    recordFailedAttempt tConnectionID, tClientIP, "login"
    revCloseDatabase tConnectionID
    return jsonError("Invalid username or password")
  end if

  -- Password verified with PBKDF2
  -- Both API and Xojo web app use compatible PBKDF2 implementations
  -- API: pbkdf2() function with HMAC-SHA256
  -- Xojo: Crypto.PBKDF2(salt, password, 10000, 32, SHA2_256)

  -- Generate JWT token
  put generateJWT(tUserData[1], tUserData[2], tUserData[5]) into tToken

  if tToken begins with "ERROR:" then
    revCloseDatabase tConnectionID
    return jsonError("Failed to generate token")
  end if

  -- Reset rate limit after successful login
  resetRateLimit tConnectionID, tClientIP, "login"

  -- Return success with token and user info
  put tToken into tResult["token"]
  put tUserData[1] into tResult["user"]["id"]
  put tUserData[2] into tResult["user"]["username"]
  put tUserData[5] into tResult["user"]["name"]
  put tUserData[4] into tResult["user"]["email"]

  -- Check if this is a one-time password (OTP = 1 means password needs to be changed)
  if tUserData[8] is "1" then
    put true into tResult["password_expired"]
  else
    put false into tResult["password_expired"]
  end if

  revCloseDatabase tConnectionID

  return jsonSuccess(tResult)
end handleLogin

function handleRefresh
  -- Require authentication (will verify current token)
  put requireAuth() into tPayload

  -- If we got here, token is valid - generate new token
  put generateJWT(tPayload["user_id"], tPayload["username"], tPayload["name"]) into tNewToken

  if tNewToken begins with "ERROR:" then
    return jsonError("Failed to refresh token")
  end if

  -- Return new token with user info
  put tNewToken into tResult["token"]
  put tPayload["user_id"] into tResult["user"]["id"]
  put tPayload["username"] into tResult["user"]["username"]
  put tPayload["name"] into tResult["user"]["name"]

  return jsonSuccess(tResult)
end handleRefresh


-- Handle password reset request
-- Generates OTP, updates user record, sends email via MailJet
function handleRequestReset pPostData
  if pPostData is empty then
    return jsonError("No data provided")
  end if

  -- Parse JSON
  put JSONParser(pPostData) into tData

  if tData is not an array then
    return jsonError("Invalid JSON format")
  end if

  put tData["email"] into tEmail

  if tEmail is empty then
    return jsonError("Email address required")
  end if

  -- Validate email format
  if not isValidEmail(tEmail) then
    return jsonError("Invalid email format")
  end if

  -- Connect to database
  put dbConnect() into tConnectionID
  if tConnectionID begins with "ERROR:" then
    return jsonError(tConnectionID)
  end if

  -- Check rate limiting for password reset requests (3 attempts per 15 minutes)
  -- IMPORTANT: Uses distinct endpoint key "requestReset" to prevent sharing counter with login attempts
  put getClientIP() into tClientIP
  put checkRateLimit(tConnectionID, tClientIP, "requestReset", 3, 900) into tRateLimitError

  if tRateLimitError is not empty then
    revCloseDatabase tConnectionID
    put header "Status: 429 Too Many Requests"
    return jsonError(tRateLimitError)
  end if

  -- Check if email exists in users table
  put "SELECT id, username, email, name FROM users WHERE email = '" & sqlEscape(tEmail) & "' AND is_active = 1" into tSQL
  put revDataFromQuery(tab, return, tConnectionID, tSQL) into tUserData

  if tUserData begins with "revdberr" or tUserData is empty then
    -- Don't reveal if email exists or not (security best practice)
    -- But still record the attempt for rate limiting
    recordFailedAttempt tConnectionID, tClientIP, "requestReset"
    revCloseDatabase tConnectionID
    -- Return success message even if email not found (prevents enumeration)
    return jsonSuccess("If this email is registered, a password reset link will be sent.")
  end if

  split tUserData by tab
  put tUserData[1] into tUserID
  put tUserData[2] into tUsername

  -- Generate 8-character random OTP
  put generateRandomString(8) into tOTP

  -- Hash the OTP with PBKDF2 (same as regular password)
  put generateSalt() into tSalt
  put hashPassword(tOTP, tSalt) into tHashedPassword

  -- Extract just the hash part (format is "salt:hash")
  set the itemDelimiter to ":"
  put item 2 of tHashedPassword into tHash

  -- Update user record: set password_hash, password_salt, OTP = 1
  put "UPDATE users SET password_hash = '" & sqlEscape(tHash) & "', password_salt = '" & sqlEscape(tSalt) & "', OTP = 1, updated_at = NOW() WHERE id = " & tUserID into tSQL
  revExecuteSQL tConnectionID, tSQL

  put the result into tResult
  if tResult begins with "revdberr" then
    revCloseDatabase tConnectionID
    return jsonError("Failed to update password")
  end if

  -- Send email via MailJet
  put "Your one-time password for ECHOIndications" into tSubject
  put "Your one-time password is:      " & tOTP & return & return & "After logging in with this password you will be asked to create a new password." into tMessage

  put sendMailJetEmail(tEmail, tSubject, tMessage) into tEmailResult

  if tEmailResult is not empty then
    -- Email failed, but password was already changed - log error but don't expose to user
    -- In production, you might want to revert the password change or queue for retry
    revCloseDatabase tConnectionID
    return jsonError("Failed to send reset email. Please try again later.")
  end if

  -- Reset rate limit on successful request
  resetRateLimit tConnectionID, tClientIP, "requestReset"

  revCloseDatabase tConnectionID

  return jsonSuccess("If this email is registered, a password reset link will be sent.")
end handleRequestReset


-- Handle password change (after OTP login)
-- Requires authentication - user must be logged in with OTP
function handleChangePassword pPostData
  -- Require authentication
  put requireAuth() into tPayload

  if pPostData is empty then
    return jsonError("No data provided")
  end if

  -- Parse JSON
  put JSONParser(pPostData) into tData

  if tData is not an array then
    return jsonError("Invalid JSON format")
  end if

  put tData["new_password"] into tNewPassword

  if tNewPassword is empty then
    return jsonError("New password required")
  end if

  -- Validate password length (minimum 8 characters recommended)
  if the length of tNewPassword < 8 then
    return jsonError("Password must be at least 8 characters long")
  end if

  -- Connect to database
  put dbConnect() into tConnectionID
  if tConnectionID begins with "ERROR:" then
    return jsonError(tConnectionID)
  end if

  -- Get user ID from token payload
  put tPayload["user_id"] into tUserID

  -- Hash the new password with PBKDF2
  put generateSalt() into tSalt
  put hashPassword(tNewPassword, tSalt) into tHashedPassword

  -- Extract just the hash part (format is "salt:hash")
  set the itemDelimiter to ":"
  put item 2 of tHashedPassword into tHash

  -- Update user record: set new password_hash, password_salt, OTP = 0
  put "UPDATE users SET password_hash = '" & sqlEscape(tHash) & "', password_salt = '" & sqlEscape(tSalt) & "', OTP = 0, updated_at = NOW() WHERE id = " & tUserID into tSQL
  revExecuteSQL tConnectionID, tSQL

  put the result into tResult
  if tResult begins with "revdberr" then
    revCloseDatabase tConnectionID
    return jsonError("Failed to update password")
  end if

  revCloseDatabase tConnectionID

  return jsonSuccess("Password updated successfully")
end handleChangePassword
?>
