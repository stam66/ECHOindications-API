<?lc
-- Changes API - Using LiveCode Arrays
-- All actions are PUBLIC (read-only access)

include "lib/db-functions.lc"

on startup
  -- Set security headers first
  setSecurityHeaders
  put header "Content-Type: application/json"

  put $_GET["action"] into tAction
  put $_GET["id"] into tID
  put $_GET["status"] into tStatus
  
  put dbConnect() into tConnectionID
  if tConnectionID begins with "ERROR:" then
    put jsonError(tConnectionID)
    exit startup
  end if
  
  switch tAction
    case "list"
      -- PUBLIC: No auth required
      put handleListChanges(tConnectionID) into tResponse
      break
    case "by_status"
      -- PUBLIC: No auth required
      put handleChangesByStatus(tConnectionID, tStatus) into tResponse
      break
    case "read"
      -- PUBLIC: No auth required
      put handleReadChange(tConnectionID, tID) into tResponse
      break
    case "count_new"
      -- PUBLIC: No auth required
      put handleCountNewChanges(tConnectionID) into tResponse
      break
    default
      put jsonError("Invalid action. Use: list, by_status, read, count_new") into tResponse
  end switch
  
  revCloseDatabase tConnectionID
  put tResponse
end startup

startup

function handleListChanges pConnectionID
  put "SELECT c.id, c.Indication_id, ind.title as indication_title," into tSQL
  put " c.changes_requestor, u.name as reporter_name," after tSQL
  put " c.changes_request, c.changes_status, c.reason_for_close," after tSQL
  put " c.created_at" after tSQL
  put " FROM changes c" after tSQL
  put " LEFT JOIN indications ind ON c.Indication_id = ind.id" after tSQL
  put " LEFT JOIN users u ON c.changes_requestor = u.username" after tSQL
  put " ORDER BY FIELD(c.changes_status, 'New', 'In progress', 'Closed'), c.created_at DESC" after tSQL
  
  put revDataFromQuery(tab, return, pConnectionID, tSQL) into tData
  
  if tData begins with "revdberr" then
    return jsonError(tData)
  end if
  
  put 1 into tIndex
  repeat for each line tLine in tData
    split tLine by tab
    
    put tLine[1] into tChanges[tIndex]["id"]
    put tLine[2] into tChanges[tIndex]["indication_id"]
    put tLine[3] into tChanges[tIndex]["indication_title"]
    put tLine[4] into tChanges[tIndex]["reported_by"]
    put tLine[5] into tChanges[tIndex]["reporter_name"]
    put tLine[6] into tChanges[tIndex]["description"]
    put tLine[7] into tChanges[tIndex]["status"]
    put tLine[8] into tChanges[tIndex]["resolution_notes"]
    put tLine[9] into tChanges[tIndex]["created_at"]
    
    add 1 to tIndex
  end repeat
  
  return jsonSuccess(tChanges)
end handleListChanges

function handleChangesByStatus pConnectionID, pStatus
  if pStatus is empty then
    return jsonError("Status required")
  end if
  
  put "SELECT c.id, c.Indication_id, ind.title as indication_title," into tSQL
  put " c.changes_requestor, u.name as reporter_name," after tSQL
  put " c.changes_request, c.changes_status, c.reason_for_close," after tSQL
  put " c.created_at" after tSQL
  put " FROM changes c" after tSQL
  put " LEFT JOIN indications ind ON c.Indication_id = ind.id" after tSQL
  put " LEFT JOIN users u ON c.changes_requestor = u.username" after tSQL
  put " WHERE c.changes_status = '" & sqlEscape(pStatus) & "'" after tSQL
  put " ORDER BY c.created_at DESC" after tSQL
  
  put revDataFromQuery(tab, return, pConnectionID, tSQL) into tData
  
  if tData begins with "revdberr" then
    return jsonError(tData)
  end if
  
  put 1 into tIndex
  repeat for each line tLine in tData
    split tLine by tab
    
    put tLine[1] into tChanges[tIndex]["id"]
    put tLine[2] into tChanges[tIndex]["indication_id"]
    put tLine[3] into tChanges[tIndex]["indication_title"]
    put tLine[4] into tChanges[tIndex]["reported_by"]
    put tLine[5] into tChanges[tIndex]["reporter_name"]
    put tLine[6] into tChanges[tIndex]["description"]
    put tLine[7] into tChanges[tIndex]["status"]
    put tLine[8] into tChanges[tIndex]["resolution_notes"]
    put tLine[9] into tChanges[tIndex]["created_at"]
    
    add 1 to tIndex
  end repeat
  
  return jsonSuccess(tChanges)
end handleChangesByStatus

function handleReadChange pConnectionID, pID
  if pID is empty then
    return jsonError("Change ID required")
  end if
  
  -- Validate ID to prevent SQL injection
  put validateNumericID(pID) into tSafeID
  if tSafeID is empty then
    return jsonError("Invalid change ID")
  end if
  
  put "SELECT c.id, c.Indication_id, ind.title as indication_title," into tSQL
  put " c.changes_requestor, u.name as reporter_name," after tSQL
  put " c.changes_request, c.changes_status, c.reason_for_close," after tSQL
  put " c.created_at" after tSQL
  put " FROM changes c" after tSQL
  put " LEFT JOIN indications ind ON c.Indication_id = ind.id" after tSQL
  put " LEFT JOIN users u ON c.changes_requestor = u.username" after tSQL
  put " WHERE c.id =" && tSafeID after tSQL
  
  put revDataFromQuery(tab, return, pConnectionID, tSQL) into tData
  
  if tData begins with "revdberr" or tData is empty then
    return jsonError("Change not found")
  end if
  
  split tData by tab
  
  put tData[1] into tChange["id"]
  put tData[2] into tChange["indication_id"]
  put tData[3] into tChange["indication_title"]
  put tData[4] into tChange["reported_by"]
  put tData[5] into tChange["reporter_name"]
  put tData[6] into tChange["description"]
  put tData[7] into tChange["status"]
  put tData[8] into tChange["resolution_notes"]
  put tData[9] into tChange["created_at"]
  
  return jsonSuccess(tChange)
end handleReadChange

function handleCountNewChanges pConnectionID
  put "SELECT COUNT(*) FROM changes WHERE changes_status = 'New'" into tSQL
  
  put revDataFromQuery(tab, return, pConnectionID, tSQL) into tData
  
  if tData begins with "revdberr" then
    return jsonError(tData)
  end if
  
  put tData into tCount["count"]
  
  return jsonSuccess(tCount)
end handleCountNewChanges
?>
